//###############################################################################
//# WbXbc - Wishbone Access Pass-Through Assertions (Pipelined)                 #
//###############################################################################
//#    Copyright 2018 Dirk Heisswolf                                            #
//#    This file is part of the WbXbc project.                                  #
//#                                                                             #
//#    WbXbc is free software: you can redistribute it and/or modify            #
//#    it under the terms of the GNU General Public License as published by     #
//#    the Free Software Foundation, either version 3 of the License, or        #
//#    (at your option) any later version.                                      #
//#                                                                             #
//#    WbXbc is distributed in the hope that it will be useful,                 #
//#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#    GNU General Public License for more details.                             #
//#                                                                             #
//#    You should have received a copy of the GNU General Public License        #
//#    along with WbXbc.  If not, see <http://www.gnu.org/licenses/>.           #
//###############################################################################
//# Description:                                                                #
//#    This set of assertion monitors a pipelined Wishbone initiator for        #
//#    protocol violations.                                                     #
//#                                                                             #
//###############################################################################
//# Version History:                                                            #
//#   October 9, 2018                                                           #
//#      - Initial release                                                      #
//###############################################################################
`default_nettype none

module wb_pass_through
  #(parameter ADR_WIDTH   = 16,  //width of the address bus
    parameter DAT_WIDTH   = 16,  //width of each data bus
    parameter SEL_WIDTH   = 2,   //number of data select lines
    parameter TGA_WIDTH   = 1,   //number of address tags
    parameter TGC_WIDTH   = 1,   //number of cycle tags
    parameter TGRD_WIDTH  = 1,   //number of read data tags
    parameter TGWD_WIDTH  = 1)   //number of write data tags

   (//Assertion control
    //-----------------
    input wire 			           pass_through_en,  //module clock

    //Clock and reset
    //---------------
    input wire 			           clk_i,            //module clock
    input wire 			           async_rst_i,      //asynchronous reset
    input wire 			           sync_rst_i,       //synchronous reset

+    //Initiator interface
    //-------------------
    input  wire                            itr_cyc_i,        //bus cycle indicator       +-
    input  wire                            itr_stb_i,        //access request            |
    input  wire                            itr_we_i,         //write enable              |
    input  wire                            itr_lock_i,       //uninterruptable bus cycle | initiator
    input  wire [SEL_WIDTH-1:0]            itr_sel_i,        //write data selects        | initiator
    input  wire [ADR_WIDTH-1:0]            itr_adr_i,        //address bus               | to
    input  wire [DAT_WIDTH-1:0]            itr_dat_i,        //write data bus            | target
    input  wire [TGA_WIDTH-1:0]            itr_tga_i,        //address tags              |
    input  wire [TGC_WIDTH-1:0]            itr_tgc_i,        //bus cycle tags            |
    input  wire [TGWD_WIDTH-1:0]           itr_tgd_i,        //write data tags           +-
    input  wire                            itr_ack_o,        //bus cycle acknowledge     +-
    input  wire                            itr_err_o,        //error indicator           | target
    input  wire                            itr_rty_o,        //retry request             | to
    input  wire                            itr_stall_o,      //access delay              | initiator
    input  wire [DAT_WIDTH-1:0]            itr_dat_o,        //read data bus             |
    input  wire [TGRD_WIDTH-1:0]           itr_tgd_o);       //read data tags            +-

    //Target interfaces
    //-----------------
    input  wire                            tgt_cyc_o,        //bus cycle indicator       +-
    input  wire                            tgt_stb_o,        //access request            |
    input  wire                            tgt_we_o,         //write enable              |
    input  wire                            tgt_lock_o,       //uninterruptable bus cycle | initiator
    input  wire [SEL_WIDTH-1:0]            tgt_sel_o,        //write data selects        | to
    input  wire [ADR_WIDTH-1:0]            tgt_adr_o,        //address bus               | target
    input  wire [DAT_WIDTH-1:0]            tgt_dat_o,        //write data bus            |
    input  wire [TGA_WIDTH-1:0]            tgt_tga_o,        //propagated address tags   |
    input  wire [TGC_WIDTH-1:0]            tgt_tgc_o,        //bus cycle tags            |
    input  wire [TGWD_WIDTH-1:0]           tgt_tgd_o,        //write data tags           +-
    input  wire                            tgt_ack_i,        //bus cycle acknowledge     +-
    input  wire                            tgt_err_i,        //error indicator           | target
    input  wire                            tgt_rty_i,        //retry request             | to
    input  wire                            tgt_stall_i,      //access delay              | initiator
    input  wire [DAT_WIDTH-1:0]            tgt_dat_i,        //read data bus             |
    input  wire [TGRD_WIDTH-1:0]           tgt_tgd_i);       //read data tags            +-

   //Abbreviations
   wire 				   req = &{~itr_stall_i, itr_cyc_i, itr_stb_i, pass_through_en};
   wire 				   ack = |{itr_ack_o, itr_err_o, itr_rty_o};

   //Care/Pass-through conditions
   //============================
   //initiator -> target 
   //itr_cyc_i,itr_stb_i -> tgt_cyc_o|tgt_stb_o
   property p_pass_through_stb;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req |-> tgt_cyc_o & tgt_stb_o;
   endproperty // p_pass_through_stb 
   a_pass_through_stb: assert property (p_pass_through_stb);

   //itr_we_i -> tgt_we_o
   property p_pass_through_we;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req |-> ~(itr_we_i ^ tgt_we_o)[*0:$] ##1 ack;
   endproperty // p_pass_through_we 
   a_pass_through_we: assert property (p_pass_through_we);

   //itr_lock_i -> tgt_lock_o
   property p_pass_through_lock;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req |-> ~(itr_lock_i ^ tgt_lock_o)[*0:$] ##1 ack;
   endproperty // p_pass_through_lock 
   a_pass_through_lock: assert property (p_pass_through_lock);

   //itr_sel_i -> tgt_sel_o
   property p_pass_through_sel;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req |-> ~(itr_sel_i ^ tgt_sel_o)[*0:$] ##1 ack;
   endproperty // p_pass_through_sel 
   a_pass_through_sel: assert property (p_pass_through_sel);

   //itr_adr_i -> tgt_adr_o
   property p_pass_through_adr;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req |-> ~|(itr_adr_i ^ tgt_adr_o)[*0:$] ##1 ack;
   endproperty // p_pass_through_adr 
   a_pass_through_adr: assert property (p_pass_through_adr);

   //itr_dat_i -> tgt_dat_o (write data)
   property p_pass_through_wdat;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req |-> ~|(itr_dat_i ^ tgt_dat_o)[*0:$] ##1 ack;
   endproperty // p_pass_through_adr 
   a_pass_through_wdat: assert property (p_pass_through_wdat);

   //itr_tga_i -> tgt_tga_o
   property p_pass_through_tga;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req |-> ~|(itr_tga_i ^ tgt_tga_o)[*0:$] ##1 ack;
   endproperty // p_pass_through_tga 
   a_pass_through_tga: assert property (p_pass_through_tga);

   //itr_tgc_i -> tgt_tgc_o
   property p_pass_through_tgc;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req |-> ~|(itr_tgc_i ^ tgt_tgc_o)[*0:$] ##1 ack;
   endproperty // p_pass_through_tgc 
   a_pass_through_tgc: assert property (p_pass_through_tgc);

   //itr_tgd_i -> tgt_tgd_o (write data tags)
   property p_pass_through_tgwd;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req |-> ~|(itr_tgc_i ^ tgt_tgc_o)[*0:$] ##1 ack;
   endproperty // p_pass_through_tgwd 
   a_pass_through_tgwd: assert property (p_pass_through_tgwd);
   
   //target -> initiator
   //tgt_ack_i -> itr_ack_o
   property p_pass_through_ack;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req [*0:$] ack |-> ~(tgt_ack_i ^ itr_ack_o);
   endproperty // p_pass_through_ack 
   a_pass_through_ack: assert property (p_pass_through_ack);

   //tgt_err_i -> itr_err_o
   property p_pass_through_err;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req [*0:$] ack |-> ~(tgt_err_i ^ itr_err_o);
   endproperty // p_pass_through_err 
   a_pass_through_err: assert property (p_pass_through_err);

   //tgt_rty_i -> itr_rty_o
   property p_pass_through_rty;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req [*0:$] ack |-> ~(tgt_rty_i ^ itr_rty_o);
   endproperty // p_pass_through_rty 
   a_pass_through_rty: assert property (p_pass_through_rty);

   //tgt_stall_i -> itr_stall_o
   property p_pass_through_stall;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	&{itr_cyc_i, itr_stb_i, pass_through_en} |-> ~(tgt_stall_i ^ itr_stall_o);
   endproperty // p_pass_through_stall 
   a_pass_through_stall: assert property (p_pass_through_stall);

   //tgt_dat_i -> itr_dat_o (read data)
   property p_pass_through_rdat;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req [*0:$] ack |-> ~|(tgt_dat_i ^ itr_dat_o);
   endproperty // p_pass_through_rdat 
   a_pass_through_rdat: assert property (p_pass_through_rdat);

   //tgt_tgd_i -> itr_tgd_o (read data tags)
   property p_pass_through_tgrd;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	req [*0:$] ack |-> ~|(tgt_tgd_i ^ itr_tgd_o);
   endproperty // p_pass_through_tgrd 
   a_pass_through_tgrd: assert property (p_pass_through_tgrd);

   //Detect unexpected target accesses
   //=================================
   property p_pass_through_false_tgt_acc;
      @(posedge clk_i) disable iff (async_rst_i|sync_rst_i)
	&{~tgt_stall_i, tgt_cyc_o, tgt_stb_o} |-> req;
   endproperty // p_pass_through_false_tgt_acc 
   a_pass_through_false_tgt_acc: assert property (p_pass_through_false_tgt_acc);

endmodule // wb_pass_through
